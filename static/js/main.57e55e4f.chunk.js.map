{"version":3,"sources":["modules/game.ts","App.tsx","index.tsx"],"names":["GameState","GameActionType","CellState","initialState","state","INIT","marked","rows","columns","mines","cells","minesMap","toKey","y","x","fromKey","key","split","parseInt","getRandomInt","min","max","Math","floor","random","updateCell","value","newState","rowData","newRow","countMinesAtPoint","counter","i","length","n","openCell","point","newCells","pointMap","points","iterPoint","EMPTY","count","MINE","forEach","p","k","push","finishGame","Object","keys","reduce","acc","EXPLOSION","reducer","action","type","START","payload","IN_GAME","Array","from","RESTART","DE_MINE","EXPLOSED","WIN","row","cell","height","width","clickKey","col","generateMinesMap","isExlosed","FLAG","MARK_MINE","isWinner","increment","markMine","every","mineKey","App","useReducer","gameState","dispatch","onClick","useCallback","e","target","dataset","onContextMenu","preventDefault","onSubmit","data","FormData","get","alert","onRestartGame","useEffect","htmlFor","required","name","id","Field","rowList","MemoRow","rowIndex","Row","cellList","MemoCell","idx","memo","cellColor","Cell","cellState","getState","style","color","backgroundColor","data-row","data-cell","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.57e55e4f.chunk.js","sourcesContent":["import { useReducer } from 'react'\n\n/**\n * TYPES\n */\n\nexport enum GameState {\n  INIT = 'init',\n  IN_GAME = 'in-game',\n  EXPLOSED = 'explosed',\n  WIN = 'win'\n}\n\nexport enum GameActionType {\n  START = 'start',\n  RESTART = 'restart',\n  DE_MINE = 'de_mine',\n  MARK_MINE = 'mark_mine'\n}\n\nexport enum CellState {\n  FLAG = 11,\n  EMPTY = 0,\n  ONE = 1,\n  TWO = 2,\n  THREE = 3,\n  FOUR = 4,\n  FIVE = 5,\n  SIX = 6,\n  SEVEN = 7,\n  EIGHT = 8,\n  MINE = 9,\n  EXPLOSION = 10\n}\n\nexport type Point = [number, number]\nexport type CellStorage = number[][]\nexport type MinesMap = {\n  [key: string]: boolean\n}\n\nexport interface Game {\n  state: GameState\n  marked: number\n  rows: number\n  columns: number\n  mines: number\n  cells: CellStorage\n  minesMap: MinesMap | null\n}\n\nexport interface GameAction<T> {\n  type: GameActionType\n  payload: T\n}\n\n/**\n * CONSTANTS\n */\n\nconst initialState: Game = {\n  state: GameState.INIT,\n  marked: 0,\n  rows: 0,\n  columns: 0,\n  mines: 0,\n  cells: [],\n  minesMap: null\n}\n\n/**\n * HELPERS\n */\n\nexport const toKey = (y: string | number, x: string | number) => `${y}-${x}`\n\nexport const fromKey = (key: string): Point => {\n  const [y, x] = key.split('-')\n\n  return [parseInt(y, 10), parseInt(x, 10)]\n}\n\nconst getRandomInt = (min: number, max: number) =>\n  Math.floor(Math.random() * (max - min)) + min\n\nexport const generateMinesMap = (\n  height: number,\n  width: number,\n  mines: number,\n  point: Point\n) => {\n  const minesMap: MinesMap = {}\n\n  let count = mines\n\n  const clickKey = toKey(...point)\n\n  while (count) {\n    let row = getRandomInt(0, height)\n    let col = getRandomInt(0, width)\n\n    const key = toKey(row, col)\n\n    if (!minesMap[key] && key !== clickKey) {\n      minesMap[key] = true\n\n      count -= 1\n    }\n  }\n\n  return minesMap\n}\n\nexport const updateCell = (\n  state: CellStorage,\n  [y, x]: Point,\n  value: CellState\n) => {\n  const newState = [...state]\n  const rowData = state[y]\n  const newRow = [...rowData]\n  newRow[x] = value\n  newState[y] = newRow\n\n  return newState\n}\n\nexport const markMine = (\n  state: CellStorage,\n  point: Point\n): [CellStorage, number] => {\n  const [y, x] = point\n\n  const rowData = state[y]\n\n  if (rowData[x] > CellState.FLAG) return [state, 0]\n\n  const newState = [...state]\n  const newRow = [...rowData]\n  let increment\n\n  if (newRow[x] === CellState.FLAG) {\n    increment = -1\n    delete newRow[x]\n  } else {\n    newRow[x] = CellState.FLAG\n    increment = 1\n  }\n\n  newState[y] = newRow\n\n  return [newState, increment]\n}\n\nexport const countMinesAtPoint = (\n  state: CellStorage,\n  [y, x]: Point,\n  minesMap: MinesMap\n) => {\n  let counter = 0\n\n  for (let i = Math.max(0, y - 1); i <= Math.min(state.length, y + 1); i++) {\n    for (\n      let n = Math.max(0, x - 1);\n      n <= Math.min(state[y].length, x + 1);\n      n++\n    ) {\n      const key = toKey(i, n)\n      if (minesMap[key]) {\n        counter += 1\n      }\n    }\n  }\n\n  return counter\n}\n\nexport const openCell = (\n  state: CellStorage,\n  point: Point,\n  minesMap: MinesMap\n): CellStorage => {\n  let newCells = [...state]\n\n  const pointMap = {\n    [toKey(...point)]: true\n  }\n\n  const points: Point[] = [\n    point\n  ]\n\n  let i = 0\n\n  while (i < points.length) {\n    const iterPoint = points[i]\n    const [y, x] = iterPoint\n\n    i++\n\n    if (\n      y < 0 ||\n      y >= state.length ||\n      x < 0 ||\n      x >= state[0].length ||\n      state[y][x] >= CellState.EMPTY ||\n      minesMap[toKey(...point)]\n    ) {\n      continue;\n    }\n  \n    const count = countMinesAtPoint(newCells, iterPoint, minesMap)\n\n    if (count >= CellState.MINE) {\n      continue;\n    }\n  \n    newCells = updateCell(newCells, iterPoint, count)\n  \n    if (count !== CellState.EMPTY) {\n      continue;\n    } else {\n      const matrix: Point[] = [\n        [y - 1, x],\n        [y + 1, x],\n        [y, x - 1],\n        [y, x + 1]\n      ]\n\n      matrix.forEach(p => {\n        const k = toKey(...p)\n        if (!pointMap[k]) {\n          points.push(p)\n          pointMap[k] = true\n        }\n      })\n    }\n  }\n\n  return newCells\n}\n\nconst finishGame = (state: CellStorage, point: Point, minesMap: MinesMap) => {\n  const newState = Object.keys(minesMap).reduce(\n    (acc, key) => updateCell(acc, fromKey(key), CellState.MINE),\n    state\n  )\n\n  return updateCell(newState, point, CellState.EXPLOSION)\n}\n\n/**\n * REDUCER\n */\n\nexport const reducer = (state: Game, action: GameAction<any>) => {\n  switch (action.type) {\n    case GameActionType.START:\n      const { rows, columns } = action.payload\n      return {\n        ...state,\n        ...action.payload,\n        state: GameState.IN_GAME,\n        cells: Array.from({ length: rows }, () =>\n          Array.from({ length: columns })\n        )\n      }\n    case GameActionType.RESTART:\n      return initialState\n    case GameActionType.DE_MINE:\n      if (state.state === GameState.EXPLOSED || state.state === GameState.WIN)\n        return state\n\n      const row = parseInt(action.payload.row, 10)\n      const cell = parseInt(action.payload.cell, 10)\n\n      let minesMap = state.minesMap,\n        point: Point = [row, cell]\n\n      if (!minesMap) {\n        minesMap = generateMinesMap(\n          state.rows,\n          state.columns,\n          state.mines,\n          point\n        )\n      }\n\n      let cells = state.cells,\n        isExlosed = minesMap[toKey(row, cell)]\n\n      if (cells?.[row]?.[cell] !== CellState.FLAG) {\n        cells = (isExlosed ? finishGame : openCell)(\n          state.cells,\n          point,\n          minesMap\n        )\n      }\n\n      return {\n        ...state,\n        cells,\n        minesMap,\n        state: isExlosed ? GameState.EXPLOSED : state.state\n      }\n    case GameActionType.MARK_MINE:\n      if (state.state === GameState.EXPLOSED || state.state === GameState.WIN)\n        return state\n\n      const [newCells, increment] = markMine(state.cells, [\n        parseInt(action.payload.row, 10),\n        parseInt(action.payload.cell, 10)\n      ])\n\n      const keys = state.minesMap && Object.keys(state.minesMap)\n\n      let isWinner\n\n      if (\n        keys?.length &&\n        keys?.every(mineKey => {\n          const [y, x] = fromKey(mineKey)\n\n          return newCells[y][x] === CellState.FLAG\n        })\n      ) {\n        isWinner = true\n      }\n\n      return {\n        ...state,\n        state: isWinner ? GameState.WIN : state.state,\n        marked: state.marked + increment,\n        cells: newCells\n      }\n    default:\n      return state\n  }\n}\n\nexport const useGameReducer = () => useReducer(reducer, initialState)\n","import React, { useCallback, useEffect, memo } from 'react'\n\nimport {\n  useGameReducer,\n  Game,\n  GameState,\n  GameActionType,\n  CellStorage,\n  CellState\n} from './modules/game'\n\nconst App = () => {\n  const [gameState, dispatch] = useGameReducer()\n\n  const { state, rows, columns, cells } = gameState\n\n  const onClick = useCallback(\n    e => {\n      if (!e.target.dataset.cell) return\n\n      dispatch({\n        type: GameActionType.DE_MINE,\n        payload: { ...e.target.dataset }\n      })\n    },\n    [dispatch]\n  )\n\n  const onContextMenu = useCallback(\n    e => {\n      e.preventDefault()\n\n      if (!e.target.dataset.cell) return\n\n      dispatch({\n        type: GameActionType.MARK_MINE,\n        payload: e.target.dataset\n      })\n    },\n    [dispatch]\n  )\n\n  const onSubmit = useCallback(\n    e => {\n      e.preventDefault()\n\n      const data = new FormData(e.target as HTMLFormElement)\n\n      const rows = parseInt(data.get('rows') as string, 10)\n      const columns = parseInt(data.get('columns') as string, 10)\n      const mines = parseInt(data.get('mines') as string, 10)\n\n      if (rows * columns < mines + 1) {\n        return alert('Mines count is too match!')\n      }\n\n      const row: any[] = Array.from({ length: columns })\n\n      const cells: CellStorage = []\n\n      for (let i = 0; i < rows; i++) {\n        cells[i] = row\n      }\n\n      dispatch({\n        type: GameActionType.START,\n        payload: {\n          rows,\n          columns,\n          mines,\n          cells\n        }\n      })\n    },\n    [dispatch]\n  )\n\n  const onRestartGame = useCallback(() => {\n    dispatch({\n      type: GameActionType.RESTART,\n      payload: null\n    })\n  }, [dispatch])\n\n  useEffect(() => {\n    if (state === GameState.WIN) alert('You win!')\n    if (state === GameState.EXPLOSED) alert('BOOM!')\n  }, [state])\n\n  if (state === GameState.INIT) {\n    return (\n      <form onSubmit={onSubmit}>\n        <label htmlFor=\"rows\">Rows:</label>\n        <input required max=\"1000\" type=\"number\" name=\"rows\" id=\"rows\" />\n        <br />\n        <label htmlFor=\"columns\">Columns:</label>\n        <input required max=\"1000\" type=\"number\" name=\"columns\" id=\"columns\" />\n        <br />\n        <label htmlFor=\"mines\">Mines:</label>\n        <input required max=\"1000\" type=\"number\" name=\"mines\" id=\"mines\" />\n        <br />\n        <button type=\"submit\">Start Game!</button>\n      </form>\n    )\n  }\n\n  return (\n    <>\n      <button onClick={onRestartGame}>Restart Game!</button>\n      <table onClick={onClick} onContextMenu={onContextMenu}>\n        <Field rows={rows} columns={columns} cells={cells} />\n      </table>\n    </>\n  )\n}\n\nexport default App\n\nconst Field: React.FC<Pick<Game, 'rows' | 'columns' | 'cells'>> = ({\n  rows,\n  columns,\n  cells\n}) => {\n  let rowList = []\n\n  for (let i = 0; i < rows; i++) {\n    rowList.push(\n      <MemoRow\n        columns={columns}\n        key={`row-${i}`}\n        rowIndex={i}\n        rowData={cells[i]}\n      />\n    )\n  }\n\n  return <tbody>{rowList}</tbody>\n}\n\nconst Row: React.FC<{ columns: number; rowIndex: number; rowData: any[] }> = ({\n  columns,\n  rowIndex,\n  rowData\n}) => {\n  let cellList = []\n\n  for (let i = 0; i < columns; i++) {\n    cellList.push(\n      <MemoCell\n        state={rowData[i]}\n        rowIndex={rowIndex}\n        key={`cell-${rowIndex}-${i}`}\n        idx={i}\n      />\n    )\n  }\n\n  return <tr>{cellList}</tr>\n}\n\nconst MemoRow = memo(Row)\n\nfunction getState(state: number) {\n  if (state === CellState.EMPTY) return null\n  if (state === CellState.MINE) return '💣'\n  if (state === CellState.FLAG) return '🚩'\n  if (state === CellState.EXPLOSION) return '💥'\n\n  return state || null\n}\n\nconst cellColor = [\n  'red',\n  'blue',\n  'green',\n  'red',\n  'purple',\n  'black',\n  'gray',\n  'maroon',\n  'turquoise'\n]\n\nconst Cell: React.FC<{ state: number; idx: number; rowIndex: number }> = ({\n  state,\n  idx,\n  rowIndex\n}) => {\n  const cellState = getState(state)\n\n  return (\n    <td\n      style={{\n        color: cellColor[state],\n        backgroundColor:\n          state >= CellState.EMPTY && state < CellState.FLAG\n            ? 'white'\n            : 'lightgray'\n      }}\n      data-row={rowIndex}\n      data-cell={idx}\n    >\n      {cellState}\n    </td>\n  )\n}\n\nconst MemoCell = memo(Cell)\n","import React from 'react'\nimport ReactDOM from 'react-dom'\n\nimport App from './App'\n\nimport './index.css'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}